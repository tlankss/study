<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
		<style type="text/css">
			*{margin: 0;padding: 0;}
			canvas {
			    border: 1px solid black;
			}
			html,body{
				height: 100%;
				width: 100%;
				display: flex;
				justify-content: center;
				align-items: center;
				background: linear-gradient(160deg,#00ff87,#00ddcc,#00b3ed,#0082d8,#3f5aa9,#4b3f81,#47255b,#3a0e37);
			}
		</style>
	</head>
	<body>
		<!-- 不要写css样式  默认长300px 高150px-->
		<canvas id="mycanvas" width="300" height="300">
			我的canvas canvas 不支持会显示
		</canvas>
	</body>
	<script type="text/javascript">
		function draw(){
			let mycanvas = document.getElementById('mycanvas')
			if(!mycanvas.getContext) return;
			let ctx = mycanvas.getContext("2d");
			
			// 画矩形 
			//ctx.fillStyle = "aqua"; //绘制图形背景颜色 
			var my_gradient=ctx.createLinearGradient(100,100,300,300); // 使用渐变 
			my_gradient.addColorStop(0,"#00ff87");
			my_gradient.addColorStop(.2,"#00ddcc");
			my_gradient.addColorStop(.4,"#00b3ed");
			my_gradient.addColorStop(.6,"#0082d8");
			my_gradient.addColorStop(.8,"#3f5aa9");
			my_gradient.addColorStop(1,"#4b3f81");
			ctx.fillStyle=my_gradient
			ctx.fillRect (100,100,100,100); //绘制矩形 参数 x轴 y轴 宽px 长px  填充的默认颜色为黑色 
			ctx.strokeRect(100,100,100,100);   // 绘制矩形边框
			ctx.clearRect(137.5,137.5,25,25) //清除指定的矩形区域，然后这块区域会变的完全透明。	
			
			//绘制路径 
			/**
			 * beginPath()=>新建一条路径
			 * moveTo(x, y)=>把画笔移动到指定的坐标(x, y),作为设置路径的起始点坐标
			 * lineTo(x,y) =>把画笔移动到指定的坐标(x, y)
			 * closePath() =>闭合路径之后，图形绘制命令又重新指向到上下文中
			 * stroke()=>通过线条来绘制图形轮廓
			 * fill()=>通过填充路径的内容区域生成实心的图形
			*/
			
			ctx.beginPath()
			ctx.moveTo(100, 100)
			ctx.lineTo(137.5, 137.5)
			ctx.moveTo(162.5, 137.5)
			ctx.lineTo(200, 100)
			ctx.moveTo(150, 162.5)
			ctx.lineTo(150, 200)
			ctx.closePath()
			ctx.stroke();
			
			// 绘制圆弧
			/**
			 *  以(x, y) 为圆心，以r 为半径，从 startAngle(起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。) 弧度开始到endAngle弧度结束。anticlosewise 是布尔值，true 表示逆时针，false 表示顺时针(默认是顺时针)。
			 * arc(x, y, r, startAngle, endAngle, anticlockwise)
			 * 需搭配beginPath() stroke()
			*/
			ctx.beginPath()
			ctx.arc(150,150,17.67,-.75*Math.PI,-.25*Math.PI,false)
			// ctx.closePath();
			ctx.stroke()
			ctx.beginPath();
			ctx.arc(50, 150, 40, -Math.PI / 2, Math.PI / 2, false);
			ctx.fill();
			/**
			 * 参数x1，y1：控制点1坐标   参数x2, y2：控制点2坐标  参数4：圆弧半径
			 * arcTo(x1, y1, x2, y2, radius): 根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。
			 */
			ctx.moveTo(100, 200);			      
			ctx.arcTo(150, 150, 200, 200, 200);
			ctx.lineTo(200, 200)
			ctx.stroke();
		}
		draw()
	</script>
</html>
